----
 - 官网文档：``http://docs.pytest.org/en/latest/``
 - 版本：pytest-3.0.3
 - 译者：怪兽穿拖鞋（TavisD）
 - 邮箱：tavisdxh@outlook.com
 - github：``https://github.com/tavisdxh/pytest-docs-zn``

-----

**Pythons**: Python 2.6,2.7,3.3,3.4,3.5, Jython, PyPy-2.3

**平台**: Unix/Posix and Windows

**PyPI包名**: pytest

**依赖**: py, colorama (Windows), argparse (py26)


# 1. 安装与入门

## 1.1 安装 

安装：

``pip install -U pytest``

检查安装的版本：

```
$ pytest --version
This is pytest version 3.0.3, imported from $PYTHON_PREFIX/lib/python3.5/site-packages/pytest.py
```

## 1.2 运行第一个test

先创建test_sample.py文件，包含一个简单的test函数


    # content of test_sample.py
    def func(x):
    return x + 1
    
    def test_answer():
    assert func(3) == 5
    
    
创建完后，执行：


    $ pytest
    ======= test session starts ========
    platform linux -- Python 3.5.2, pytest-3.0.3, py-1.4.31, pluggy-0.4.0
    rootdir: $REGENDOC_TMPDIR, inifile:
    collected 1 items
    test_sample.py F
    ======= FAILURES ========
    _______ test_answer ________
    
    def test_answer():
    >   assert func(3) == 5
    E   assert 4 == 5
    E   + where 4 = func(3)
    
    test_sample.py:5: AssertionError
    ======= 1 failed in 0.12 seconds ========


得到的是错误的结果，因为func(3)的返回值不等于5

> 备注：你可以简单地使用assert语句来断言测试期望值。pytest的高级断言内省可以智能地反馈断言表达式的中间值，使你从学习很多名字的Junit传统方法痛苦中解放出来。

## 1.3 运行多个test

pytest会执行当前目录及其子目录下的所有test_*.py或*_test.py格式的文件。一般来说，Pytest遵循标准test发现规则。

## 1.4 断言引起某种异常

如果你想断言某些代码引起异常，可以使用raises助手：


	# content of test_sysexit.py
	import pytest
	def f():
	    raise SystemExit(1)
	    
	def test_mytest():
	    with pytest.raises(SystemExit):
	        f()


这次使用"quite"报告模式来运行：

	
	$ pytest -q test_sysexit.py
	.
	1 passed in 0.12 seconds


## 1.5 在class中将多个test分组

一旦你开始有多个test时，常常将它们按class和module逻辑地分组才显得有意义。我们写一个类包含两个test的：


	# content of test_class.py
	class TestClass:
	    def test_one(self):
	        x = "this"
	        assert 'h' in x
	        
	    def test_two(self):
	        x = "hello"
	        assert hasattr(x, 'check')


这两个test可以被找到是因为标准的python test发现机制约定。不需要子类的任何东西。我们通过传入模块的文件名就可以简单地运行它。


	$ pytest -q test_class.py
	.F
	======= FAILURES ========
	_______ TestClass.test_two ________
	
	self = <test_class.TestClass object at 0xdeadbeef>
	
	    def test_two(self):
	        x = "hello"
	>       assert hasattr(x, 'check')
	E       assert False
	E           + where False = hasattr('hello', 'check')
	
	test_class.py:8: AssertionError
	1 failed, 1 passed in 0.12 seconds


第一个test通过，第二个failed。此外我们可以简单地看到断言时的中间值，这可以帮忙我们明白失败的原因。


## 1.6 功能：请求一个唯一的临时目录

对于功能测试通常需要创建一些文件并将它们传递给应用程序对象。pytest提供可以请求任意资源的内置fixture/function参数，例如一个唯一的临时目录：

	# content of test_tmpdir.py
	def test_needsfiles(tmpdir):
	    print (tmpdir)
	    assert 0


我们列出temdir在test函数签名的名字，在执行test函数之前，pytest会查找并调用fixture工厂去创建该资源。运行：


	$ pytest -q test_tmpdir.py
	F
	======= FAILURES ========
	_______ test_needsfiles ________
	
	tmpdir = local('PYTEST_TMPDIR/test_needsfiles0')
	
	    def test_needsfiles(tmpdir):
	        print (tmpdir)
	>       assert 0
	E       assert 0
	
	test_tmpdir.py:3: AssertionError
	--------------------------- Captured stdout call ---------------------------
	PYTEST_TMPDIR/test_needsfiles0
	1 failed in 0.12 seconds


在test执行前，一个唯一的每个test都会调用的临时目录被创建了。更多信息查看“临时目录和文件”。
输入以下内容可以查看内置的pytest fixtures:明确的、模块化的、可伸缩的.

```
pytest --fixtures # shows builtin and custom fixtures
```

## 1.7 下一站

建议：

- 2.1 通过 python -m pytest 调用pytest  命令行调用例子
- 24 good practices for virtualenv, test layout
- 5 pytest fixtures: explicit, modular, scalable for providing a functional baseline to your tests
- 19 Writing plugins managing and writing plugins






