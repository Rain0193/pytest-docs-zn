----
 - 官网文档：``http://docs.pytest.org/en/latest/``
 - 版本：pytest-3.0.3
 - 译者：怪兽穿拖鞋（TavisD）
 - 邮箱：tavisdxh@outlook.com
 - github：``https://github.com/tavisdxh/pytest-docs-zn``

-----

**Pythons**: Python 2.6,2.7,3.3,3.4,3.5, Jython, PyPy-2.3
**平台**: Unix/Posix and Windows
**PyPI包名**: pytest
**依赖**: py, colorama (Windows), argparse (py26)


# 1. 安装与入门

## 1.1 安装 

安装：

``pip install -U pytest``

检查安装的版本：

```
$ pytest --version
This is pytest version 3.0.3, imported from $PYTHON_PREFIX/lib/python3.5/site-packages/pytest.py
```

## 1.2 运行第一个test

先创建test_sample.py文件，包含一个简单的test函数

```
# content of test_sample.py    
def func(x):
    return x + 1
    
def test_answer():
    assert func(3) == 5
```

创建完后，执行：

```
$ pytest
======= test session starts ========
platform linux -- Python 3.5.2, pytest-3.0.3, py-1.4.31, pluggy-0.4.0
rootdir: $REGENDOC_TMPDIR, inifile:
collected 1 items
test_sample.py F
======= FAILURES ========
_______ test_answer ________

    def test_answer():
>       assert func(3) == 5
E       assert 4 == 5
E       + where 4 = func(3)

test_sample.py:5: AssertionError
======= 1 failed in 0.12 seconds ========

```
得到的是错误的结果，因为func(3)的返回值不等于5

> 备注：你可以简单地使用assert语句来断言测试期望值。pytest的高级断言内省可以智能地反馈断言表达式的中间值，使你从学习很多名字的Junit传统方法痛苦中解放出来。

## 1.3 运行多个test

pytest会执行当前目录及其子目录下的所有test_*.py或*_test.py格式的文件。一般来说，Pytest遵循标准test发现规则。

## 1.4 断言引起某种异常

如果你想断言某些代码引起异常，可以使用raises助手：

```
# content of test_sysexit.py
import pytest
def f():
    raise SystemExit(1)
    
def test_mytest():
    with pytest.raises(SystemExit):
        f()
```

这次使用"quite"报告模式来运行：

```
$ pytest -q test_sysexit.py
.
1 passed in 0.12 seconds
```

## 1.5 在class中将多个test分组

一旦你开始有多个test时，常常将它们按class和module逻辑地分组才显得有意义。我们写一个类包含两个test的：

```
# content of test_class.py
class TestClass:
    def test_one(self):
        x = "this"
        assert 'h' in x
        
    def test_two(self):
        x = "hello"
        assert hasattr(x, 'check')
```

这两个test可以被找到是因为标准的python test发现机制约定。不需要子类的任何东西。我们通过传入模块的文件名就可以简单地运行它。

```
$ pytest -q test_class.py
.F
======= FAILURES ========
_______ TestClass.test_two ________

self = <test_class.TestClass object at 0xdeadbeef>

    def test_two(self):
        x = "hello"
>       assert hasattr(x, 'check')
E       assert False
E           + where False = hasattr('hello', 'check')

test_class.py:8: AssertionError
1 failed, 1 passed in 0.12 seconds

```
第一个test通过，第二个failed。此外我们可以简单地看到断言时的中间值，这可以帮忙我们明白失败的原因。


## 1.6 功能：请求一个唯一的临时目录

对于功能测试通常需要创建一些文件并将它们传递给应用程序对象。pytest提供可以请求任意资源的内置fixture/function参数，例如一个唯一的临时目录：

```
# content of test_tmpdir.py
def test_needsfiles(tmpdir):
    print (tmpdir)
    assert 0
```

我们列出temdir在test函数签名的名字，在执行test函数之前，pytest会查找并调用fixture工厂去创建该资源。运行：

```
$ pytest -q test_tmpdir.py
F
======= FAILURES ========
_______ test_needsfiles ________

tmpdir = local('PYTEST_TMPDIR/test_needsfiles0')

    def test_needsfiles(tmpdir):
        print (tmpdir)
>       assert 0
E       assert 0

test_tmpdir.py:3: AssertionError
--------------------------- Captured stdout call ---------------------------
PYTEST_TMPDIR/test_needsfiles0
1 failed in 0.12 seconds
```

在test执行前，一个唯一的每个test都会调用的临时目录被创建了。更多信息查看“临时目录和文件”。
输入以下内容可以查看内置的pytest fixtures:明确的、模块化的、可伸缩的.

```
pytest --fixtures # shows builtin and custom fixtures
```








