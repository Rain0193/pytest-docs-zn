---- - 官网文档：``http://docs.pytest.org/en/latest/`` - 版本：pytest-3.0.7 - 译者：怪兽穿拖鞋（TavisD） - 邮箱：tavisdxh@outlook.com - github：``https://github.com/tavisdxh/pytest-docs-zn``-----# 2. 使用和调用## 2.1 通过 python -m pytest 调用pytest可以通过Python解释器从命令行调用test    python -m pytest [...]等同于pytest [...]，而且Python也会有把当前目录添加到sys.path## 2.2 可用的退出码pytest执行结果有6个不同的退出码：    Exit code 0 所有用例都被收集且执行通过    Exit code 1 收集的用例已执行，但有些执行失败    Exit code 2 用户中断    Exit code 3 执行时发生内部错误    Exit code 4 pytest命令使用错误    Exit code 5 没有收集到test## 2.3 获取版本、选项名称、环境变量的帮助信息	pytest --version # 展示Pytest的导入路径	pytest --fixtures # 展示可用的内置函数参数	pytest -h | --help # 展示命令行帮助信息和配置文件选项## 2.4 第一（N）次失败后停止    pytest -x # 第一次失败时停止    pytest --maxfail=2 # 第二次失败时停止## 2.5 指定tests/选择tests    pytest test_mod.py # 模块里执行test    pytest somepath # 执行somepath目录下所有tests    pytest -k stringexpr # 只执行名字符合“字符串表达式”的test    pytest test_mod.py::test_func # 只执行对应节点的test。如test_mod.py文件里的test_func方法。    pytest test_mod.py::TestClass::test_method # 只执行对应文件及class下的方法导入"pkg"，并使用它的文件系统位置去查找并执行tests：    pytest --pyargs pkg # 执行pkg目录下所有的tests## 2.6 修改Python的回溯打印    pytest --showlocals # 展示追溯的本地变量    pytest -l # 展示本地变量（缩写）    pytest --tb=auto # (默认) 'long' 第一个和最后一个入口的回溯，'short'是其他入口的回溯    pytest --tb=long # 详尽,格式化信息回溯    pytest --tb=short # 短回溯格式化    pytest --tb=line # 每个失败的第一行    pytest --tb=native # Python标准库格式化    pytest --tb=no # 没有回溯``--full-trace``打印比``--tb=long``还详细的回溯，同时会包含键盘中断（Ctrl + C）的回溯。如果test花费太长时间，而用Ctrl + C中断找原因时，非常有用。默认不会展示输出（因为键盘中断是pytest引起的）。确保回溯展示了再使用该选项。## 2.7 失败时跳转到PDB(Python调试器)Python提供了称为PDB的内置Python调试器。pytest可以通过一个命令行选项跳转到PDB。    pytest --pdb这每次失败时都会调用Python调试器。通常你可能只是想第一个test失败时才跳转，去了解某些失败情况:    pytest -x --pdb # 第一次失败时跳转到PDB，然后中止test session    pytest --pdb --maxfail=3 # 前三个失败时跳转到PDB注意任意失败的异常信息都存储在``sys.last_value``, ``sys.last_type`` 和``sys.last_traceback``. 在交互式使用中，可以使用任何调试工具进行调试。还可以手动访问异常信息。例如：    >>> import sys    >>> sys.last_traceback.tb_lineno    42    >>> sys.last_value    AssertionError('assert result == "ok"',)## 2.8 设置断点/aka set_trace()如果你想设置断点并进入``pdb.set_trace()``，可以使用助手：    import pytest    def test_function():        ...        pytest.set_trace() # 调用PDB并追踪pytest 2.4.0以后，可以使用原生Python导入``pdb``,``pdb.set_trace()``来进入PDB回溯，而不必使用``pytest.set_trace()``装饰器或通过``pytest -s``显式禁用pytest的输出捕获。## 2.9 分析测试执行时间获取最慢的10个测试时间    pytest --durations=10## 2.10 创建JunitXML格式文件创建可以被Jenkins或其他持续集成服务器识别的结果文件，使用这种调用：    pytest --junitxml=path在path路径创建一个XML文件### 2.10.1 record_xml_property如果要记录test的附加日志信息，可以使用``record_xml_property``fixture：    def test_function(record_xml_property):        record_xml_property("example_key", 1)        assert 0这会增加一个额外属性``example_key="1"``在生成的``testcase``标签里。    <testcase classname="test_function" file="test_function.py" line="0" name="test_function" time="0.0009">        <properties>            <property name="example_key" value="1" />        </properties>    </testcase>> **注意** ：``record_xml_property``是一个实验功能。### 2.10.2 LogXML: add_global_property如果要在testsuite级别添加属性节点，该属性节点可能包含与所有测试用例相关的属性您可以使用``LogXML.add_global_properties``    import pytest    @pytest.fixture(scope="session")    def log_global_env_facts(f):        if pytest.config.pluginmanager.hasplugin('junitxml'):            my_junit = getattr(pytest.config, '_xml', None)        my_junit.add_global_property('ARCH', 'PPC')        my_junit.add_global_property('STORAGE_TYPE', 'CEPH')    @pytest.mark.usefixtures(log_global_env_facts)    def start_and_prepare_env():        pass    class TestMe:        def test_foo(self):            assert True这将在testsuite节点下面添加一个属性节点到生成的xml:    <testsuite errors="0" failures="0" name="pytest" skips="0" tests="1" time="0.006">        <properties>            <property name="ARCH" value="PPC"/>            <property name="STORAGE_TYPE" value="CEPH"/>        </properties>        <testcase classname="test_me.TestMe" file="test_me.py" line="16" name="test_foo" time="0.000243663787842"/>    </testsuite>> **注意** ：实验性功能。## 2.11 创建resultlog格式文件3.0版本后弃用。    pytest --resultlog=path## 2.12 发送测试报告到在线pastebin服务为每次test失败创建URL：    pytest --pastebin=failed这会将测试运行信息提交给远程“Paste”服务，并为每个失败提供一个URL。你可以选择像往常一样测试，或者添加例如``-x``，如果你只想发送一个特定的失败。为整个test session日志创建URL:    pytest --pastebin=all## 2.13 禁用插件禁止在调用时加载特定插件，使用``-p``选项和``no:``前缀：例子：要禁止加载``doctest``插件，这是一个从文本文件执行doctest tests的插件，像这样调用pytest：    pytest -p no:doctest## 2.14 从Python代码调用Pytest可以直接从Python代码调用pytest：    pytest.main()这就像从命令行调用"pytest"一样。它不会引起``SystemExit``异常，而是返回exitcode。可以传递选项和参数：    pytest.main(['-x', 'mytestdir'])还可以指定附加插件到``pytest.main``：    # content of myinvoke.py    import pytest    class MyPlugin:        def pytest_sessionfinish(self):            print("*** test run reporting finishing")    pytest.main(["-qq"], plugins=[MyPlugin()])运行会显示MyPlugin会被添加当它的勾子被调用后：    $ python myinvoke.py    *** test run reporting finishing